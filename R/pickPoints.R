#' @title Interactively Pick Points and Group Data
#' @description A Shiny Widget to Inspect Points and Define Groups in Existing bvt and NicePlots Graphs
#'
#' @details
#' Todo<-1
#'
#' @param data A saved plot of class npData (plots generated by bvt and NicePlots)
#' @param dataTable An optional table of phenotype data used to explore point and group characteristics
#' @param selectFillCol A valid R color used as the fill color for selected points
#' @param selectLineCol A valid R color used for the outline of selected points
#' @param selectSize A cex size of selected points
#'
#' @examples
#' ToDo<-1
#'
#' @importFrom NicePlots setAlpha basicTheme
#' @importFrom graphics points
#' @seealso \code{\link[bvt]{genePlot}}
pick_points <- function(data,dataTable=NULL,selectFillCol=setAlpha("gold",0.6),selectLineCol=setAlpha("darkgoldenrod1",0.9),selectSize=1.5) {
  if(requireNamespace("shiny",quietly = TRUE) & requireNamespace("miniUI",quietly = TRUE) == FALSE){
    stop("Missing required libraries for interactive shiny UI. Please install shiny and miniUI.")
  }
  tFact<-1
  dfilter<- seq(nrow(data$options$x)) %in% data$options$xypos$ID
  if(data$options$pointHighlights==FALSE) {
    tFact<-factor(rep("Group 1",length(unique(data$options$xypos$ID))))
    levels(tFact)<-c("Group 1", "Group 2")
  } else {
    if(is.vector(data$options$by)) {
      tFact<-factor(data$options$by[dfilter])
    } else {
      if(data$options$subgroup==TRUE) {
        tFact<-factor(data$options$by[dfilter,min(3,ncol(data$options$by))])
      } else {
        tFact<-factor(data$options$by[dfilter,min(3,ncol(data$options$by))])
      }
    }
  }

  ui <- miniUI::miniPage(
    miniUI::gadgetTitleBar(paste("Select points")),
    miniUI::miniContentPanel(padding = 0,
      shiny::plotOutput("plot1", height = "100%", brush = "brush", hover = "hover", click="plot_click")
    ),
    miniUI::miniContentPanel(padding = 0, style="background-color: #BEBEBE33",
      shiny::fillRow(height = "65px",flex=c(1,2,2,2),
        shiny::fillCol(style = "margin-top: 25px;",
          shiny::actionButton("clearSelection",label="Clear",icon=shiny::icon("ban"),width="95%")
        ),
        shiny::fillCol(style = "margin-top: 25px;",
          shiny::actionButton("Select",label="Select",icon=shiny::icon("check-circle"),width="95%")
        ),
        shiny::fillCol(
          shiny::selectInput("groupLevels",label="Select Level",choices = if(any(as.character(tFact) != "Group 1")){tFact}else{c("Group 1", "Group 2")}, selected=if(any(as.character(tFact) != "Group 1")){as.character(tFact[1])}else{"Group 2"},width="95%")
        ),
        shiny::fillCol(
          shiny::textInput("groupNames", label="Level Name", value=if(any(as.character(tFact) != "Group 1")){as.character(tFact[1])} else {"Group 2"}, width="95%")
        )
      ),
      shiny::fillRow(height = "65px",flex=c(1,2,2,2),
        shiny::fillCol(style = "margin-top: 25px;",
          shiny::br()
        ),
        shiny::fillCol(
          shiny::actionButton("newGroup",label="New Group",icon=shiny::icon("plus-square"),width="95%")
        ),
        shiny::fillCol(
          shiny::actionButton("addToGroup",label="Add to Level",icon=shiny::icon("arrow-right"),width="95%")
        ),
        shiny::fillCol(
          shiny::actionButton("delGroup",label="Remove Level",icon=shiny::icon("trash-alt"),width="95%")
        )
      )
    ),
    miniUI::miniContentPanel(padding=0,
      shiny::h4("Data Point Inspector"),
      shiny::fillRow(height = "40px",
        shiny::fillCol(
          shiny::textOutput("Inspector")
        )
      ),
      shiny::h4("Factor Summary Table"),
      shiny::fillRow(style="background-color: #FFFFFFFF",flex=1,
        shiny::fillCol(
          shiny::tableOutput("FactorStats")
        )
      )
    )
  )

  server<-function(input, output, session) {
    #shiny::reactiveValues(pGroup=rep("A",nrow(data$options$xypos)), selected=rep(FALSE,nrow(data$options$xypos)))
    pointGroup<-shiny::reactiveValues()
    pointGroup$selected<-rep(FALSE,nrow(data$options$xypos))
    pointGroup$pGroup<-tFact

    brushed<-shiny::reactive({
      bpoints<-shiny::brushedPoints(data$options$xypos, xvar = "x", yvar="y", input$brush, allRows = TRUE)$selected_
      sIDS<-unlist(unique(data$options$xypos$ID[bpoints]))
    })

    shiny::observe({
      input$plot_click
      npoint<-shiny::nearPoints(data$options$xypos,  xvar = "x", yvar="y", allRows=T, coordinfo=input$plot_click,maxpoints=1)$selected_
      if(!is.null(npoint)){
        shiny::isolate({
          sID<-data$options$xypos$ID[npoint]
          pointGroup$selected[which(data$options$xypos$ID == sID)] <- !pointGroup$selected[which(data$options$xypos$ID == sID)]
        })
      }
    })

    shiny::observe({
      input$hover
      npoint<-shiny::nearPoints(data$options$xypos,  xvar = "x", yvar="y", allRows=T, coordinfo=input$hover,maxpoints=1)$selected_
      if(!is.null(npoint)){
        IDpos<-as.numeric(data$options$xypos$ID[npoint])
        ID<-data$options$xypos$ID[npoint]
        if(!is.null(rownames(data$options$x))){
          ID<-rownames(data$options$x)[IDpos]
        }
        value<-if(is.vector(data$options$x)){
            paste0("Expression = ", data$options$x[IDpos])
          } else {
            paste(colnames(data$options$x), round(data$options$x[IDpos,],4), sep=" = ", collapse=", ")
          }
        output$Inspector<-shiny::renderText(paste0("ID = ",ID,", Group = ",as.character(pointGroup$pGroup)[IDpos],", ",value))
      }
    })

    output$plot1<-shiny::renderPlot({
      genePlot(data,pointSize=0, RSOveride=TRUE, highlight = pointGroup$pGroup, legend="Legend")
      points(data$options$xypos[,1:2], pch=16, col=data$options$theme$plotColors$points[rep(pointGroup$pGroup,nrow(data$options$xypos)/length(pointGroup$pGroup))])
      bIDs<-brushed()
      bSelected<-data$options$xypos$ID %in% bIDs
      points(data$options$xypos[pointGroup$selected | bSelected,1:2], bg=selectLineCol,col=selectFillCol,pch=21, cex=selectSize)
    })

    output$FactorStats<-shiny::renderTable(
      bind_cols(data$options$x, factor=data$options$by,Group=pointGroup$pGroup) %>%
        pivot_longer(cols=if(is.vector(data$options$x)){1}else{seq(ncol(data$options$x))}, names_to = "Feature",values_to="Expression") %>%
        group_by(Group,Feature) %>%
        summarize(N=n(),Median_Expression=paste0(round(median(Expression),3)," (",round(min(Expression),3), "-",round(max(Expression),3),")"), .groups = 'drop') %>%
        ungroup() %>%
        spread(key=Feature,value=Median_Expression)
    )

    shiny::observeEvent(input$clearSelection, {
      pointGroup$selected <- rep(FALSE,nrow(data$options$xypos))
    })

    shiny::observeEvent(input$Select, {
      bIDs<-brushed()
      pointGroup$selected[data$options$xypos$ID %in% bIDs] <- TRUE
    })

    shiny::observeEvent(input$groupLevels, {
      cSel<-shiny::renderText(input$groupLevels)
      shiny::updateTextInput(session,inputId = "groupNames", val=cSel())
    })

    shiny::observeEvent(input$groupNames, {
      newName<-shiny::renderText(input$groupNames)
      oldName<-shiny::renderText(input$groupLevels)
      if(!is.null(newName())) {
        if(newName() != oldName() & newName() != "" & !newName() %in% levels(pointGroup$pGroup) ) {
          cLab<-levels(pointGroup$pGroup)
          cLab[which(cLab==oldName())]<-newName()
          levels(pointGroup$pGroup)<-cLab
          shiny::updateSelectInput(session,inputId = "groupLevels", choices=levels(pointGroup$pGroup),selected = newName())
        }
      }
    })

    shiny::observeEvent(input$newGroup, {
      levels(pointGroup$pGroup)<-c(levels(pointGroup$pGroup),paste0("Group ",length(levels(pointGroup$pGroup))+1))
      shiny::updateSelectInput(session,inputId = "groupLevels", choices=levels(pointGroup$pGroup), selected = paste0("Group ",length(levels(pointGroup$pGroup))+1))
    })

    shiny::observeEvent(input$addToGroup, {
      cLevel<-shiny::renderText(input$groupLevels)
      bIDs<-brushed()
      bSelected<-data$options$xypos$ID %in% bIDs
      pointGroup$pGroup[unique(data$options$xypos$ID[bSelected | pointGroup$selected])]<-cLevel()
      pointGroup$selected <- rep(FALSE,nrow(data$options$xypos))
    })

    shiny::observeEvent(input$delGroup, {
      dLevel<-shiny::renderText(input$groupLevels)
      cLevels<-levels(pointGroup$pGroup)
      if(length(cLevels)>1) {
        cLevels<-cLevels[cLevels!=dLevel()]
        tfact<-as.character(pointGroup$pGroup)
        tfact[which(as.character(pointGroup$pGroup)==dLevel())]<-cLevels[1]
        tfact<-factor(tfact)
        levels(tfact)<-cLevels
        pointGroup$pGroup<-tfact
        shiny::updateSelectInput(session,inputId = "groupLevels", choices=levels(pointGroup$pGroup), selected = levels(pointGroup$pGroup)[1])
      }
    })

    shiny::observeEvent(input$cancel, {
      shiny::stopApp(NULL)
    })

    shiny::observeEvent(input$done, {
      #outFact<-shiny::reactiveValuesToList(pointGroup$pGroup)
      shiny::stopApp(returnValue = pointGroup$pGroup)
    })
  }
  viewer<-shiny::dialogViewer(dialogName = "Interactive Data Inpector and Factor Creator",height = 2000)
  shiny::runGadget(ui, server, viewer = viewer)
}
#bind_cols(zh$options$x, factor=zh$options$by) %>% pivot_longer(cols=1:length(zh$options$x), names_to = "Genes_Isoforms",values_to="Expression") %>% group_by(factor,Genes_Isoforms) %>% summarize(mean(Expression))


