#' @title Interactively Pick Points and Group Data
#' @description A Shiny Widget to Inspect Points and Define Groups in Existing bvt and NicePlots Graphs
#'
#' @details
#' Todo<-1
#'
#' @param data A saved plot of class npData (plots generated by bvt and NicePlots)
#' @param dataTable An optional table of phenotype data used to explore point and group characteristics
#' @param selectFillCol A valid R color used as the fill color for selected points
#' @param selectLineCol A valid R color used for the outline of selected points
#' @param selectSize A cex size of selected points
#'
#' @examples
#' ToDo<-1
#'
#' @importFrom NicePlots setAlpha basicTheme
#' @importFrom graphics points
#' @seealso \code{\link[bvt]{genePlot}}
pick_points <- function(data,dataTable=NULL,selectFillCol=setAlpha("gold"),selectLineCol=setAlpha("darkgoldenrod1"),selectSize=1.5) {
  if(requireNamespace("shiny",quietly = TRUE) & requireNamespace("miniUI",quietly = TRUE) == FALSE){
    stop("Missing required libraries for interactive shiny UI. Please install shiny and miniUI.")
  }
  ui <- miniUI::miniPage(
    miniUI::gadgetTitleBar(paste("Select points")),
    miniUI::miniContentPanel(padding = 0,
      shiny::plotOutput("plot1", height = "100%", brush = "brush", click="plot_click")
    ),
    miniUI::miniContentPanel(padding = 0, style="background-color: #BEBEBE33",
      shiny::fillRow(height = "65px",flex=c(1,2,2,2),
        shiny::fillCol(style = "margin-top: 25px;",
          shiny::actionButton("clearSelection",label="Clear",icon=shiny::icon("ban"),width="95%")
        ),
        shiny::fillCol(style = "margin-top: 25px;",
          shiny::actionButton("Select",label="Select",icon=shiny::icon("check-circle"),width="95%")
        ),
        shiny::fillCol(
          shiny::selectInput("groupLevels",label="Select Level",choices = c("Group A", "Group B"), selected="Group A",width="95%")
        ),
        shiny::fillCol(
          shiny::textInput("groupNames", label="Level Name", value = "Group A",width="95%")
        )
      ),
      shiny::fillRow(flex=c(1,2,2,2),
        shiny::fillCol(style = "margin-top: 25px;",
          shiny::br()
        ),
        shiny::fillCol(
          shiny::actionButton("newGroup",label="New Group",icon=shiny::icon("plus-square"),width="95%")
        ),
        shiny::fillCol(
          shiny::actionButton("addToGroup",label="Add to Level",icon=shiny::icon("arrow-right"),width="95%")
        ),
        shiny::fillCol(
          shiny::actionButton("delGroup",label="Remove Level",icon=shiny::icon("trash-alt"),width="95%")
        )
      ),
      miniUI::miniContentPanel(padding = 0,
        shiny::fillCol(
          shiny::fillRow(
            shiny::tableOutput("descriptive")
          )
        )
      )
    )
  )

  server<-function(input, output, session) {
    #shiny::reactiveValues(pGroup=rep("A",nrow(data$options$xypos)), selected=rep(FALSE,nrow(data$options$xypos)))
    pointGroup<-shiny::reactiveValues()
    pointGroup$selected<-rep(FALSE,nrow(data$options$xypos))
    dfilter<- seq(nrow(data$options$x) %in% data$options$xypos$ID)
    if(data$options$pointHighlights==FALSE) {
      tFact<-factor(rep("Group 1",length(unique(data$options$xypos$ID))))
      levels(tFact)<-c("Group 1", "Group 2")
      pointGroup$pGroup<-tFact
    } else {
      if(is.vector(data$options$by)) {
        pointGroup$pGroup<-data$options$by[dfilter]
      } else {
        if(data$options$subgroup==TRUE) {
          pointGroup$pGroup<-data$options$by[dfilter,min(3,ncol(data$options$by))]
        } else {
          pointGroup$pGroup<-data$options$by[dfilter,min(2,ncol(data$options$by))]
        }
      }
    }
    #updateSelectInput(session, inputId = "groupLevels",choices = levels(pointGroup$pGroup), selected = levels(pointGroup$pGroup[1]))

    brushed<-shiny::reactive({
      bpoints<-shiny::brushedPoints(data$options$xypos, xvar = "x", yvar="y", input$brush, allRows = TRUE)$selected_
      sIDS<-unlist(unique(data$options$xypos$ID[bpoints]))
    })

    shiny::observe({
      input$plot_click
      npoint<-shiny::nearPoints(data$options$xypos,  xvar = "x", yvar="y", allRows=T, coordinfo=input$plot_click,maxpoints=1)$selected_
      if(!is.null(npoint)){
        shiny::isolate({
          sID<-data$options$xypos$ID[npoint]
          pointGroup$selected[which(data$options$xypos$ID == sID)] <- !pointGroup$selected[which(data$options$xypos$ID == sID)]
        })
      }
    })

    output$plot1<-shiny::renderPlot({
      genePlot(data,pointSize=0, RSOveride=TRUE)
      points(data$options$xypos[,1:2], pch=16, col=data$options$theme$plotColors$points[rep(pointGroup$pGroup,nrow(data$options$xypos)/length(pointGroup$pGroup))])
      bIDs<-brushed()
      bSelected<-data$options$xypos$ID %in% bIDs
      points(data$options$xypos[pointGroup$selected | bSelected,1:2], bg=selectLineCol,col=selectFillCol,pch=21, cex=selectSize)
    })

    shiny::observeEvent(input$clearSelection, {
      pointGroup$selected <- rep(FALSE,nrow(data$options$xypos))
    })

    shiny::observeEvent(input$Select, {
      bIDs<-brushed()
      pointGroup$selected[data$options$xypos$ID %in% bIDs] <- TRUE
    })

    shiny::observeEvent(input$groupLevels, {
      cSel<-shiny::renderText(input$groupLevels)
      shiny::updateTextInput(session,inputId = "groupNames", val=cSel())
    })

    shiny::observeEvent(input$groupNames, {
      newName<-shiny::renderText(input$groupNames)
      oldName<-shiny::renderText(input$groupLevels)
      if(newName() != oldName()) {
        cLab<-levels(pointGroup$pGroup)
        cLab[which(cLab==oldName())]<-newName()
        levels(pointGroup$pGroup)<-cLab
        shiny::updateSelectInput(session,inputId = "groupLevels", choices=levels(pointGroup$pGroup),selected = newName())
      }
    })

    shiny::observeEvent(input$newGroup, {
      levels(pointGroup$pGroup)<-c(levels(pointGroup$pGroup),paste0("Group ",length(levels(pointGroup$pGroup))+1))
      shiny::updateSelectInput(session,inputId = "groupLevels", choices=levels(pointGroup$pGroup), selected = paste0("Group ",length(levels(pointGroup$pGroup))+1))
    })

    shiny::observeEvent(input$addToGroup, {
      cLevel<-shiny::renderText(input$groupLevels)
      bIDs<-brushed()
      bSelected<-data$options$xypos$ID %in% bIDs
      pointGroup$pGroup[unique(data$options$xypos$ID[bSelected | pointGroup$selected])]<-cLevel()
      pointGroup$selected <- rep(FALSE,nrow(data$options$xypos))
    })

    shiny::observeEvent(input$delGroup, {
      dLevel<-shiny::renderText(input$groupLevels)
      cLevels<-levels(pointGroup$pGroup)
      if(length(cLevels)>1) {
        cLevels<-cLevels[cLevels!=dLevel()]
        tfact<-as.character(pointGroup$pGroup)
        tfact[which(as.character(pointGroup$pGroup)==dLevel())]<-cLevels[1]
        tfact<-factor(tfact)
        levels(tfact)<-cLevels
        pointGroup$pGroup<-tfact
        shiny::updateSelectInput(session,inputId = "groupLevels", choices=levels(pointGroup$pGroup), selected = levels(pointGroup$pGroup)[1])
      }
    })

    shiny::observeEvent(input$cancel, {
      shiny::stopApp(NULL)
    })

    shiny::observeEvent(input$done, {
      #outFact<-shiny::reactiveValuesToList(pointGroup$pGroup)
      shiny::stopApp(returnValue = pointGroup$pGroup)
    })
  }
  viewer<-shiny::dialogViewer(dialogName = "Interactive Data Inpector and Factor Creator",height = 2000)
  shiny::runGadget(ui, server, viewer = viewer)
}
#bind_cols(zh$options$x, factor=zh$options$by) %>% pivot_longer(cols=1:length(zh$options$x), names_to = "Genes_Isoforms",values_to="Expression") %>% group_by(factor,Genes_Isoforms) %>% summarize(mean(Expression))


